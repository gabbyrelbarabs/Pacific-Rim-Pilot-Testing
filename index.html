<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pacific Rim: Pilot Training</title>
<link rel="shortcut icon" type="image/x-icon" href="ppdc.ico" />
<style>
  :root { --bg:#030604; --panel:#07200a; --accent:#00ff66; --muted:#6ee7a7; color-scheme: dark; }
  body, button, input, select, textarea {
    font-family: "TT Lakes Neue", "TT Lakes Neue LT", "Microgramma", sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }
  body { background: radial-gradient(ellipse at center, #051009 0%, #010201 70%); color:var(--accent); margin:0; padding:18px; }
  h1 { margin:6px 0 16px; font-size:22px; color:var(--accent); text-shadow:0 0 8px rgba(0,255,120,0.08); }
  h2 { color:var(--muted); font-weight:700; margin:6px 0; }
  .center { text-align:center; }
  .container { max-width:1200px; margin:0 auto; }
  .row { display:flex; gap:12px; text-align:center;}
  .panel { background:linear-gradient(180deg, rgba(0,255,120,0.02), rgba(0,255,120,0.01)); border:1px solid rgba(0,255,120,0.06); padding:12px; border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,0.6); }
  .main-row { display:flex; gap:16px; align-items:flex-start; }
  .left { width:360px; }
  .right { flex:1; min-width:420px; }
  button { background:linear-gradient(180deg,#062510,#04170d); color:var(--accent); border:1px solid rgba(0,255,120,0.06); padding:8px 10px; border-radius:8px; cursor:pointer; font-family:inherit; }
  button:disabled { opacity:0.45; cursor:not-allowed; }
  .small { font-size:13px; padding:6px 8px; }
  .stat { font-size:13px; color:var(--muted); }
  .stats-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px; }
  .log { height:320px; overflow:auto; background:rgba(0,0,0,0.45); padding:8px; border-radius:8px; font-family:inherit; font-size:13px; color:var(--accent); }
  .log div { padding:6px 4px; border-bottom:1px dashed rgba(0,255,120,0.02); }
  .big { font-weight:700; font-size:16px; }
  .hpbar { height:12px; background:rgba(255,255,255,0.02); border-radius:6px; overflow:hidden; }
  .hpbar > i { display:block; height:100%; background:linear-gradient(90deg,#16a34a,#86efac); width:100%; }
  .kaiju-hp > i { background:linear-gradient(90deg,#ff4040,#ff9696); }
  .fov { position:fixed; left:0; top:0; right:0; bottom:0; background:rgba(0,255,120,0); pointer-events:none; transition:background 0.25s ease; mix-blend-mode:screen; z-index:50; }
  .fov.on { background:rgba(0,255,80,0.12); }
  .warning-box { position:fixed; right:18px; top:18px; background:rgba(0,0,0,0.6); border:1px solid rgba(0,255,120,0.12); color: #001a00; padding:10px 12px; border-radius:8px; z-index:51; display:none; }
  .warning-box.on { display:block; color:var(--accent); background:linear-gradient(180deg, rgba(0,30,0,0.6), rgba(0,10,0,0.9)); box-shadow:0 6px 30px rgba(0,255,120,0.05); }
  .controls-hint { font-size:12px; color:var(--muted); margin-top:6px; }
  .jaeger-list { display:flex; flex-direction:column; gap:8px; }
  .jaeger-item { display:flex; justify-content:space-between; align-items:center; padding:8px; border-radius:8px; background:rgba(0,0,0,0.15); cursor:pointer; }
  .selected { outline:2px solid rgba(0,255,120,0.18); box-shadow:0 6px 20px rgba(0,255,120,0.03) inset; }
  .muted-block { color:var(--muted); font-size:13px; }
  .title-screen { display:flex; flex-direction:column; gap:12px; align-items:center; justify-content:center; min-height:380px; }
  .hidden { display:none !important; }
  .qte-count { font-weight:800; font-size:18px; color:var(--accent); text-shadow:0 0 6px rgba(0,255,120,0.08); }
  .kbd { background:rgba(0,0,0,0.2); padding:4px 8px; border-radius:6px; margin-left:6px; color:var(--muted); font-weight:700; }
  .overlay { position:fixed; left:0; top:0; right:0; bottom:0; display:flex; align-items:center; justify-content:center; z-index:200; background:linear-gradient(rgba(0,0,0,0.6), rgba(0,0,0,0.8)); }
  .result-box { width:520px; background:rgba(0,10,0,0.9); border:1px solid rgba(0,255,120,0.12); padding:20px; border-radius:12px; color:var(--accent); }
  .result-line { margin:8px 0; color:var(--muted); }
  .result-main { font-size:20px; font-weight:900; color:var(--accent); margin-bottom:8px; }
  #transitionOverlay { position:fixed; left:0; top:0; right:0; bottom:0; z-index:9999; background:#000; opacity:0; display:none; transition:opacity 0.5s linear; }


/* small changes: keep init dots on same line, keep glow visible */
#initScreen .glow {
  position:absolute;
  width: 30vw;
  height: 30vw;
  min-width:200px;
  min-height:200px;
  border-radius:50%;
  background: radial-gradient(circle at center, rgba(124,252,0,0.18), rgba(124,252,0,0.06), rgba(0,0,0,0));
  filter: blur(30px);
  animation: glowGrow 4s ease-in-out forwards;
  pointer-events:none;
}

/* animation grows and stays visible (no fade-out to 0 opacity) */
@keyframes glowGrow {
  0%   { transform: scale(0.4);  opacity: 0.6; }
  50%  { transform: scale(1.15); opacity: 1;   }
  100% { transform: scale(1.15); opacity: 1;   } /* stays visible */
}

/* display status dots inline with title */
#initScreen .sub {
  font-size:14px;
  color:#bfffc7;
  opacity:0.9;
  margin:0 0 0 8px;        /* small left spacing from title */
  display:inline-block;    /* keep dots on the same line as the title */
  vertical-align:middle;
}
</style>

<style>
/* Initiation screen styles */
#initScreen {
  position: fixed;
  inset: 0;
  background: #000;
  z-index: 9999;
  display: flex;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  color: #7CFC00;
  font-family: 'Orbitron', monospace;
  text-align:center;
  transition: opacity 1000ms ease;
}
#initScreen.hidden { opacity: 0; pointer-events:none; }


  50% { transform: scale(1.15); opacity:1; }
  100% { transform: scale(1.6); opacity:0.0; }
}
#initScreen .panel {
  position:relative;
  z-index: 2;
  max-width: 80%;
}
#initScreen h1 {
  margin:0;
  font-size:28px;
  letter-spacing:1px;
  color:#8bff7a;
  text-shadow: 0 0 8px rgba(124,252,0,0.25);
}
#initScreen p { margin:8px 0 0 0; color:#9fffa0; opacity:0.95; }

#initScreen .clickHint { margin-top:16px; font-size:14px; color:#bfffc7; display:none; }
#initStatus {
  margin-left: 8px;
  font-weight: normal;
}
</style>
</head>
<body>
<div id="initScreen" aria-hidden="false">
  <div class="glow" aria-hidden="true"></div>
  <div class="panel">
    <h1><span id="initTitle">Initiating Systems</span><span id="initStatus" class="sub"></span></h1>
    <div id="initClickHint" class="clickHint">Click to continue</div>
  </div>
</div>

<audio id="bgAudioA" loop preload="auto"></audio>
<audio id="bgAudioB" loop preload="auto" style="display:none"></audio>
<audio id="sfxAudio" preload="auto"></audio>

<div class="container">
  <div id="menuScreen" class="panel title-screen">
    <div style="max-width:960px;">
      <h1 class="center">Pacific Rim: Pilot Training</h1>
      <div class="center muted-block">Text-based Battle Simulator</div>
      <div style="height:18px"></div>
      <div class="center">
		<br>
        <button id="playBtn" style="font-size:16px;padding:12px 18px;">BEGIN</button><br>
        <button id="instructionsBtn" style="font-size:16px;margin-top:10px;padding:12px 24px;">INSTRUCTIONS</button>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Created by: Gabriel Barabar</p>
      </div>
      <div style="height:18px"></div>
      <div id="instructionsPanel" class="hidden panel" style="margin-top:12px;">
        <h2>Instructions & Jaeger Information</h2>
        <div class="muted-block"><b>Hotkeys</b>: <br>Movement/Status: <span class="kbd">W</span> Forward · <span class="kbd">S</span> Backwards · <span class="kbd">F</span> Taunt<br>Offense: <span class="kbd">Z</span> (1) · <span class="kbd">X</span> (2) · <span class="kbd">C</span> (3) · <span class="kbd">V</span> (4)<br> Defense: <span class="kbd">A</span> (Dodge left) · <span class="kbd">D</span> (Dodge right) · <span class="kbd">Space</span> (Block)</div>
		<br>
        <div id="instructionsJaegers"></div>
        <div style="height:8px"></div>
        <div class="muted-block">Note: When a Kaiju attacks, a quick-time event will trigger, prompting you to dodge or block before it lands. If you fail to do anything, the Kaiju will attempt to hit you, however, you might still be able to dodge based on your Jaeger's agility.</div>
		<br>
	  </div>
    </div>
  </div>

  <div id="deployScreen" class="panel hidden">
    <div class="row" style="justify-content:space-between; text-align:center;">
      <div>
        <h2>Mission Briefing</h2>
        <div class="muted-block">Current Mission:</div>
        <div style="margin-top:8px;">
          <div>Category: <span id="deployKaijuCat" class="big">—</span></div>
          <div>Time of Day: <span id="deployTimeOfDay" class="big">—</span></div>
          <div>Location: <span id="deployLocation" class="big">—</span></div>
          <div>Weather Status: <span id="deployWeather" class="big">—</span></div>
        </div>
      </div>
	  <div id="jaegerPreview" class="jaeger-preview panel" style="width:340px; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:12px;">
		<div id="jaegerPreviewHeader" style="align-self:centert font-weight:600; margin-bottom:20px;"><b>Jaeger Blueprints:</b></div>
		<div id="jaegerPreviewBody" style="width:100%; display:flex; align-items:center; justify-content:center; min-height:120px;">
		  <img id="jaegerPreviewImg" src="" alt="Jaeger preview" style="max-width:100%; max-height:500px; display:none; border-radius:8px;" />
		  <div id="jaegerPreviewEmpty" style="display:none; padding:20px; border:1px dashed rgba(255,255,255,0.08); border-radius:6px; text-align:center;">
			Select a Jaeger to view blueprints
		  </div>
		</div>
	  </div>
      <div style="width:340px;">
        <h2>Jaeger Deployment</h2>
        <div class="muted-block">Choose a Jaeger — Deploy only enabled after selection</div>
        <div style="height:8px"></div>
        <div id="jaegerSelection" class="jaeger-list"></div>
        <div style="height:8px"></div>
        <button id="deployBtn" disabled>DEPLOY</button>
      </div>
    </div>
  </div>

  <div id="battleScreen" class="panel hidden">
    <div class="main-row">
      <div class="left panel">
        <div class="row" style="justify-content:space-between;">
          <div><button id="backToDeploy">← RETREAT</button></div>
          <div class="stat">Mode: <span id="modeLabel" class="stat">SETUP</span></div>
        </div>
        <div style="height:8px"></div>
        <div class="stats-grid">
          <div>
            <div class="stat">Kaiju Category</div>
            <div id="kaijuCategory" class="big">—</div>
          </div>
          <div>
            <div class="stat">Battlefield</div>
            <div id="battlefield" class="big">—</div>
          </div>
          <div>
            <div class="stat">Weather</div>
            <div id="weather" class="big">—</div>
          </div>
          <div>
            <div class="stat">Starting Distance</div>
            <div id="startDistance" class="big">—</div>
          </div>
        </div>
        <div style="margin-top:6px;">
          <div class="stat">Selected Jaeger</div>
          <div class="jaeger-card" id="jaegerCard">
            <div><span id="jName" class="big">—</span> <span id="jStats" class="stat" style="margin-left:6px"></span></div>
            <div style="margin-top:6px;">
              <div class="stat">HP</div>
              <div class="hpbar"><i id="jHP" style="width:100%"></i></div>
            </div>
            <div style="margin-top:6px;">
              <div class="stat">Moves</div>
              <div id="moveBtns" style="display:flex;flex-direction:column;gap:6px;margin-top:6px;"></div>
              <div class="controls-hint">Hotkeys:<br><br>· Z (1)<br>· X (2)<br>· C (3)<br>· V (4)</div>
            </div>
          </div>
        </div>
      </div>

      <div class="right panel">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <div>
            <div class="stat">Kaiju Info</div>
            <div class="kaiju-card" style="margin-top:6px;">
              <div><span id="kName" class="big">—</span> <span id="kStats" class="stat"></span></div>
              <div style="margin-top:6px;">
                <div class="stat">HP</div>
                <div class="hpbar kaiju-hp"><i id="kHP" style="width:100%"></i></div>
              </div>
            </div>
          </div>

          <div style="width:260px;">
            <div class="stat">Distance (m)</div>
            <div class="big center" id="distance">—</div>
            <div style="margin-top:6px;" class="stat">Actions</div>
            <div style="display:flex;gap:8px;margin-top:6px;justify-content:center;">
			  <button id="moveFwd" class="small">Move Forward</button>
			  <button id="moveBack" class="small">Move Back</button>
			  <button id="tauntBtn" class="small">Taunt</button>
			</div>
            <div style="margin-top:8px;" id="cooldownNote" class="disabled-note"></div>
            <div style="margin-top:6px;" class="controls-hint">Dodge: A (Left) · D (Right) · Space (Block)</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <div class="stat">Battle Log</div>
          <div class="log" id="log"></div>
        </div>

        <div style="margin-top:10px;">
          <div id="qteArea" style="display:none;">
            <div class="stat">Quick Time Event ACTIVE — Quick! Dodge or Block!</div>
            <div style="display:flex;gap:8px;margin-top:8px;justify-content:center;">
              <button id="dodgeLeft">Dodge Left (A)</button>
              <button id="block">Block (Space)</button>
              <button id="dodgeRight">Dodge Right (D)</button>
            </div>
            <div class="stat" style="margin-top:6px;">Time left: <span id="qteTimer" class="qte-count">2.0</span>s</div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="resultOverlay" class="overlay hidden">
    <div class="result-box">
      <div id="resultMain" class="result-main">Mission Status</div>
      <div id="resultStats"></div>
      <div style="height:10px"></div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
        <button id="retryBtn" class="small">RETRY</button>
        <button id="redeployBtn" class="small">REDEPLOY</button>
        <button id="mainMenuBtn" class="small">MAIN MENU</button>
      </div>
    </div>
  </div>

  <div id="fov" class="fov"></div>
  <div id="warnBox" class="warning-box"><div id="warnText"></div></div>

</div>

<div id="transitionOverlay"></div>

<script>
  const battlefields = ['City', 'Field', 'Sea', 'Underwater'];
  const weathers = ['Stormy', 'Dry'];
  const timesOfDay = ['Day','Night'];

  const JAEGERS = {
    'Gipsy Danger': {
      mark: 'Mark-III',
      power: 8, agility: 7, armor: 6, maxHP: 160,
      height: '79 m', weight: '1,980 t',
      moves: [
        {id:'hammer', name:'Hammer Strike', type:'melee', mult:1.5, cd:1700, desc:'Double-arm down slam.'},
        {id:'jet', name:'Jet Punch', type:'melee', mult:1.2, cd:1500, desc:'Jet-propulsed punch.'},
        {id:'plasma', name:'Plasma Cannon', type:'ranged', mult:2.0, cd:2100, unusableIn:['Underwater'], desc:'High-energy blast of plasma.'},
        {id:'reactor', name:'Reactor Burnout', type:'ranged', mult:2.7, cd:3500, selfHPcostPct:0.10, desc:'Massive thermal damage, costs HP (10%).'}
      ]
    },
    'Cherno Alpha': {
      mark: 'Mark-I',
      power: 10, agility: 3, armor: 10, maxHP: 180,
      height: '85 m', weight: '2,400 t',
      moves: [
        {id:'plasmf', name:'Plasma Fist', type:'melee', mult:1.6, cd:2000, unusableIn:['Sea'], desc:'Devastating electric melee.'},
        {id:'flame', name:'Flamethrower', type:'ranged', mult:1.8, cd:2800, unusableInWeather:['Stormy'], desc:'Reactor-based flamethrower.'},
        {id:'hydraulic', name:'Hydraulic Punch', type:'melee', mult:2.0, cd:3000, desc:'Hydraulics-boosted attack.'},
        {id:'tcharge', name:'Titan Charge', type:'melee', mult:2.5, cd:4500, unusableIn:['City'], selfHPcostPct:0.08, desc:'Charge with full weight.'}
      ]
    },
    'Striker Eureka': {
      mark: 'Mark-V',
      power: 10, agility: 10, armor: 9, maxHP: 120,
      height: '76 m', weight: '1,750 t',
      moves: [
        {id:'six', name:'Six Shooter', type:'ranged', mult:2.5, cd:4000, desc:'Anti-Kaiju Missiles.'},
        {id:'twin', name:'Twin Slasher', type:'melee', mult:1.0, cd:1450, desc:'Assault Mount 3.25 Sting Blades.'},
        {id:'rapid', name:'Power Combo', type:'melee', mult:1.1, cd:1350, unusableIn:['Underwater'], desc:'High velocity punches.'},
        {id:'serrate', name:'Serration', type:'melee', mult:1.3, cd:1550, desc:'Serrated blades attachment to Sting Blades.'}
      ]
    }, 'Crimson Typhoon': {
	  mark: 'Mark-IV',
      power: 8, agility: 9, armor: 6, maxHP: 150,
      height: '76 m', weight: '1,900 t',
      moves: [
        {id:'z_dual_strike', name:'Triple Strike', type:'melee', mult:1.2, cd:1500, desc:'Rapid strike combo with all limbs.'},
        {id:'x_overthrow', name:'Overthrow', type:'melee', mult:2.0, cd:2500, unusableIn:['Underwater'], desc:'Counter overthrow.'},
        {id:'c_thundercloud', name:'Thundercloud Formation', type:'melee', mult:2.2, cd:3300, unusableIn:['City'], desc:'Saw-transformed hands to rapidly attack target.'},
        {id:'v_snipe', name:'Plasma Snipe', type:'ranged', mult:3.0, cd:4500, unusableIn:['City'], desc:'Long-range precision shot from IB22 Plasmacaster.'}
      ]
    },
    'Diablo Intercept': {
      power: 8, agility: 7, armor: 8, maxHP: 150,
      mark: 'Mark-II',
      height: '82 m', weight: '2,100 t',
      moves: [
        {id:'z_hell_punch', name:'Hell Punch', type:'melee', mult:1.3, cd:1700, unusableInWeather:['Stormy'], unusableIn:['Sea','Underwater'], desc:'Devastating flame-engulfed punch.'},
        {id:'x_flamethrower', name:'Flamethrower', type:'ranged', mult:1.8, cd:2300, unusableIn:['Underwater'], desc:'High-pressure flamethrower.'},
        {id:'c_hellbot_reign', name:'Hellbot Reign', type:'ranged', mult:2.0, cd:2600, unusableIn:['Underwater'], desc:'Summon homing, explosive Hellbot drones.'},
        {id:'v_infernado', name:'Infernado', type:'melee', mult:2.0, cd:2400, unusableInWeather:['Stormy'], unusableIn:['Sea','Underwater', 'City'], desc:'Fire-engulfed spin tactic.'}
      ]
    },
    'Coyote Tango': {
      power: 7, agility: 5, armor: 4, maxHP: 140,
      mark: 'Mark-I',
      height: '74 m', weight: '1,600 t',
      moves: [
        {id:'z_canine_assault', name:'Canine Assault', type:'melee', mult:1.1, cd:1300, desc:'Rush strike.'},
        {id:'x_shellcrusher', name:'Shellcrusher', type:'melee', mult:1.6, cd:2300, desc:'Heavy strike to body.'},
        {id:'c_throwdown', name:'Throwdown', type:'melee', mult:1.9, cd:2700, unusableIn:['Underwater', 'City'], desc:'Powerful counter/reversal.'},
        {id:'v_plasma_mortar', name:'Plasma Mortar', type:'ranged', mult:2.6, cd:3500, unusableIn:['Underwater'], desc:'Powerful shots from rear mortars.'}
      ]
    },
	'Warrior Exodus': {
      power: 10, agility: 9, armor: 9, maxHP: 170,
      mark: 'Mark-VI',
      height: '84 m', weight: '2,050 t',
      moves: [
        {id:'z_twist_and_turn', name:'Twist and Turn', type:'melee', mult:1.9, cd:3100, desc:'Close combat emergency tactic.'},
        {id:'x_guerilla', name:'Guerilla', type:'melee', mult:1.4, cd:2200, desc:'Unpredictable barrage of attacks.'},
        {id:'c_left_right_goodnight', name:'Left Right Goodnight', type:'melee', mult:1.6, cd:2500, desc:'Synergized barrage of punches.'},
        {id:'v_core_burst', name:'Core Burst', type:'ranged', mult:2.5, cd:5000, selfHPcostPct:0.10, desc:'Forced core meltdown.'}
      ]
    }
  };

  const KAIJU_BASE = {
    'I': {power:6, agility:3, armor:5, maxHP:100, namePrefix:'Lesser'},
    'II':{power:8, agility:5, armor:6, maxHP:150, namePrefix:'Minor'},
    'III':{power:10, agility:8, armor:8, maxHP:200, namePrefix:'Standard'},
    'IV':{power:15, agility:9, armor:10, maxHP:250, namePrefix:'Heavy'},
    'V': {power:20, agility:10, armor:15, maxHP:320, namePrefix:'Alpha'},
    'VI':{power:32, agility:7, armor:20, maxHP:500, namePrefix:'Mega'}
  };

  const KAIJU_NAMES = {
    'I': [
      'Karloff','Hardship','Hammerjaw','Ceptid','Tengu','Rippers','Minor Kaiju'
    ],
    'II': [
      'Onibaba','Raythe','Clawhook','Lesser Kaiju'
    ],
    'III': [
      'Yamarashi','Knifehead','Atticon','Huo Da','Tarantulos','Hammerhorn','Acidquill','Greater Kaiju'
    ],
    'IV': [
      'Otachi','Leatherback','Gyakushu','Mutavore','Spinejackal','Raiju','Scunner','Hakuja','Shrikethorn','Jawhide','Copperhead','Trespasser','Heavy Kaiju'
    ],
    'V': [
      'Slattern','Raijin','Crabcakes','Frightcrawler','Alpha Kaiju'
    ],
    'VI': [
      'Breacher','Mega-Kaiju'
    ]
  };

  const KAIJU_MOVES = [
    {id:'bite', name:'Bite', type:'melee', mult:1.0, desc:'Close-range bite.'},
    {id:'tail', name:'Tail Swipe', type:'melee', mult:1.1, desc:'Sweeping tail.'},
    {id:'stomp', name:'Stomp', type:'melee', mult:1.0, desc:'Heavy stomp.'},
    {id:'beam', name:'Bio Beam', type:'ranged', mult:1.3, desc:'Ranged bio-beam.'},
    {id:'spit', name:'Acid Spit', type:'ranged', mult:1.2, desc:'Irritating corrosive spit.'}
  ];

  const state = {
    battlefield:null, weather:null, timeOfDay:null, kaijuCategory:null,
    jaeger:null, kaiju:null,
    distance:null,
    mode:'SETUP',
    cooldowns:{},
    globalDisableUntil:0,
    globalDisableExcept: null,
    globalDisableTimeoutId: null,
    gameOver:false,
    kaijuIntervalId:null, kaijuPendingAttack:null, qteTimeoutId:null,
    snapshot:null,
    totalDamageDealt:0,
    battleStartTime:null
  };

  const menuScreen = document.getElementById('menuScreen');
  const instructionsBtn = document.getElementById('instructionsBtn');
  const instructionsPanel = document.getElementById('instructionsPanel');
  const instructionsJaegers = document.getElementById('instructionsJaegers');
  const playBtn = document.getElementById('playBtn');

  const deployScreen = document.getElementById('deployScreen');
  const deployKaijuCat = document.getElementById('deployKaijuCat');
  const deployLocation = document.getElementById('deployLocation');
  const deployWeather = document.getElementById('deployWeather');
  const deployTimeOfDay = document.getElementById('deployTimeOfDay');
  const jaegerSelection = document.getElementById('jaegerSelection');
  const deployBtn = document.getElementById('deployBtn');
  
  const jaegerPreviewImg = document.getElementById('jaegerPreviewImg');
const jaegerPreviewEmpty = document.getElementById('jaegerPreviewEmpty');

if (jaegerPreviewImg) {
  jaegerPreviewImg.onload = function() {
    if (jaegerPreviewEmpty) jaegerPreviewEmpty.style.display = 'none';
    jaegerPreviewImg.style.display = 'block';
  };

  jaegerPreviewImg.onerror = function() {
    jaegerPreviewImg.style.display = 'none';
    jaegerPreviewImg.src = '';
    if (jaegerPreviewEmpty) {
      jaegerPreviewEmpty.style.display = 'block';
      jaegerPreviewEmpty.textContent = 'No blueprints of this Jaeger are public';
    }
  };
}

function updateJaegerPreview(name) {
  const map = {
    'Gipsy Danger': 'gipsy.png',
    'Cherno Alpha': 'cherno.png',
    'Diablo Intercept': 'diablo.png',
    'Striker Eureka': 'striker.png',
    'Crimson Typhoon': 'crimson.png',
    'Coyote Tango': 'coyote.png',
	'Warrior Exodus': 'warrior.png'
  };

  if (!jaegerPreviewImg || !jaegerPreviewEmpty) return;

  if (!name) {
    jaegerPreviewImg.style.display = 'none';
    jaegerPreviewImg.src = '';
    jaegerPreviewEmpty.style.display = 'block';
    jaegerPreviewEmpty.textContent = 'Select a Jaeger to view blueprints';
    return;
  }

  const filename = map[name];
  if (!filename) {
    jaegerPreviewImg.style.display = 'none';
    jaegerPreviewImg.src = '';
    jaegerPreviewEmpty.style.display = 'block';
    jaegerPreviewEmpty.textContent = 'No blueprints of this Jaeger are public';
    return;
  }

  jaegerPreviewEmpty.style.display = 'none';
  jaegerPreviewImg.style.display = 'none';
  jaegerPreviewImg.src = filename;
}

  const battleScreen = document.getElementById('battleScreen');
  const backToDeploy = document.getElementById('backToDeploy');
  const kaijuCategoryEl = document.getElementById('kaijuCategory');
  const battlefieldEl = document.getElementById('battlefield');
  const weatherEl = document.getElementById('weather');
  const startDistanceEl = document.getElementById('startDistance');
  const jNameEl = document.getElementById('jName');
  const jStatsEl = document.getElementById('jStats');
  const jHPbar = document.getElementById('jHP');
  const kNameEl = document.getElementById('kName');
  const kStatsEl = document.getElementById('kStats');
  const kHPbar = document.getElementById('kHP');
  const distanceEl = document.getElementById('distance');
  const logEl = document.getElementById('log');
  const moveBtnsDiv = document.getElementById('moveBtns');
  const moveFwdBtn = document.getElementById('moveFwd');
  const moveBackBtn = document.getElementById('moveBack');
  const cooldownNote = document.getElementById('cooldownNote');
  const modeLabel = document.getElementById('modeLabel');
  const fovEl = document.getElementById('fov');
  const qteArea = document.getElementById('qteArea');
  const qteTimerEl = document.getElementById('qteTimer');
  const warnBox = document.getElementById('warnBox');
  const warnText = document.getElementById('warnText');
  const sfxAudio = document.getElementById('sfxAudio');
  const tauntBtn = document.getElementById('tauntBtn');

  const dodgeLeftBtn = document.getElementById('dodgeLeft');
  const dodgeRightBtn = document.getElementById('dodgeRight');
  const blockBtn = document.getElementById('block');

  const resultOverlay = document.getElementById('resultOverlay');
  const resultMain = document.getElementById('resultMain');
  const resultStats = document.getElementById('resultStats');
  const retryBtn = document.getElementById('retryBtn');
  const redeployBtn = document.getElementById('redeployBtn');
  const mainMenuBtn = document.getElementById('mainMenuBtn');

  const transitionOverlay = document.getElementById('transitionOverlay');

  const randInt = (min,max) => Math.floor(Math.random()*(max-min+1))+min;
  const clamp = (v,a,b) => Math.max(a,Math.min(b,v));
  function log(text) {
    const d = new Date().toLocaleTimeString();
    const entry = document.createElement('div');
    entry.textContent = `${d} — ${text}`;
    logEl.appendChild(entry);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function transitionTo(callback) {
    return new Promise(resolve => {
      transitionOverlay.style.display = 'block';
      requestAnimationFrame(()=> { transitionOverlay.style.opacity = '1'; });
      setTimeout(()=> {
        try { callback(); } catch(e){ console.error(e); }
        setTimeout(()=> {
          transitionOverlay.style.opacity = '0';
          setTimeout(()=> {
            transitionOverlay.style.display = 'none';
            resolve();
          }, 500);
        }, 20);
      }, 500);
    });
  }

  function populateInstructions() {
    instructionsJaegers.innerHTML = '';
    Object.keys(JAEGERS).forEach(name=>{
      const j = JAEGERS[name];
      const el = document.createElement('div');
      el.className = 'panel';
      el.style.marginBottom = '8px';
      el.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;">
        <div><strong>${name}</strong><div class="muted-block">${j.height} · ${j.weight}</div></div>
        <div class="muted-block">Power:${j.power} Agi:${j.agility} Armor:${j.armor}</div>
      </div>
      <div style="margin-top:6px;font-size:13px;color:var(--muted)"><strong>Moves:</strong> ${j.moves.map(m=>m.name+' ('+m.type+')').join(' · ')}</div>`;
      instructionsJaegers.appendChild(el);
    });
  }
  instructionsBtn.onclick = () => { instructionsPanel.classList.toggle('hidden'); };

  function pickKaijuCategory() {
    const weights = [
      {cat: 'I',   w: 13},
      {cat: 'II',  w: 17},
      {cat: 'III', w: 30},
      {cat: 'IV',  w: 25},
      {cat: 'V',   w: 10},
      {cat: 'VI',  w: 5}
    ];
    const total = weights.reduce((s, x) => s + x.w, 0);
    let r = Math.random() * total;
    for (let i = 0; i < weights.length; i++) {
      r -= weights[i].w;
      if (r <= 0) return weights[i].cat;
    }
    return weights[weights.length - 1].cat;
  }

  function prepareDeployScreen() {
    state.battlefield = battlefields[randInt(0,battlefields.length-1)];
    state.weather = weathers[randInt(0,weathers.length-1)];
    state.timeOfDay = timesOfDay[randInt(0,timesOfDay.length-1)];
    state.kaijuCategory = pickKaijuCategory();
    deployKaijuCat.innerText = 'Category ' + state.kaijuCategory;
    deployLocation.innerText = state.battlefield;
    deployWeather.innerText = state.weather;
    deployTimeOfDay.innerText = state.timeOfDay;
    jaegerSelection.innerHTML = '';
	updateJaegerPreview(null);
    Object.keys(JAEGERS).forEach(name=>{
      const tpl = JAEGERS[name];
      const item = document.createElement('div');
      item.className = 'jaeger-item';
      item.dataset.name = name;
      item.innerHTML = `<div>
          <div style="font-weight:800">${name} <span style="font-weight:400;color:var(--muted);font-size:12px">${tpl.mark ? '('+tpl.mark+')' : ''}</span></div>
          <div class="muted-block">${tpl.height} · ${tpl.weight}</div>
        </div>
        <div style="text-align:right">
          <div class="muted-block">Pwr:${tpl.power} Agi:${tpl.agility} Arm:${tpl.armor}</div>
          <div style="height:6px"></div>
          <div class="muted-block" style="font-size:12px">${tpl.moves.map((m,i)=>(''+(i+1)+'. '+m.name)).join(' · ')}</div>
        </div>`;
      item.onclick = () => {
        document.querySelectorAll('.jaeger-item').forEach(n=>n.classList.remove('selected'));
        item.classList.add('selected');
        state.jaeger = {
          key:name, name,
          mark: tpl.mark || '',
          power:tpl.power, agility:tpl.agility, armor:tpl.armor,
          height: tpl.height || '', weight: tpl.weight || '',
          maxHP:tpl.maxHP, hp:tpl.maxHP,
          moves: JSON.parse(JSON.stringify(tpl.moves))
        };
        deployBtn.disabled = false;
		updateJaegerPreview(name);
      };
      jaegerSelection.appendChild(item);
    });
  }

  playBtn.onclick = () => {
    transitionTo(()=> {
      menuScreen.classList.add('hidden');
      deployScreen.classList.remove('hidden');
      prepareDeployScreen();
      populateInstructions();
      state.mode = 'DEPLOY';
      log('Entered deployment briefing.');
    });
  };

  deployBtn.onclick = () => {
    if(!state.jaeger) { alert('Select a Jaeger for deployment.'); return; }
    log(`Jaeger selected for deployment: ${state.jaeger.name}`);
    state.snapshot = {
      jaegerKey: state.jaeger.key,
      kaijuCategory: state.kaijuCategory,
      battlefield: state.battlefield,
      weather: state.weather,
      timeOfDay: state.timeOfDay,
      startDistance: randInt(85,200)
    };
	updateJaegerPreview(state.snapshot.jaegerKey);
    transitionTo(()=> {
      deployScreen.classList.add('hidden');
      battleScreen.classList.remove('hidden');
      startBattleFromSnapshot();
    });
  };

  backToDeploy.addEventListener('click', () => {
    if(state.mode === 'BATTLE' && !state.gameOver) {
      log(`${state.jaeger && state.jaeger.name ? state.jaeger.name : '${shortName(state.jaeger)}'} has retreated! Mission failed.`);
      showResultOverlay('retreat');
      endGame('surrender','lose');
    } else {
      transitionTo(()=> { prepareDeployScreen(); });
    }
  });

  function createKaijuFromCategory(cat) {
    const base = (typeof KAIJU_BASE !== 'undefined' && KAIJU_BASE[cat]) ? KAIJU_BASE[cat] : {
      hp: 100, armor: 0, agility: 0, moves: [], namePrefix: ('Category ' + cat)
    };
    const namesList = (typeof KAIJU_NAMES !== 'undefined' && KAIJU_NAMES[cat]) ? KAIJU_NAMES[cat].slice() : [base.namePrefix || ('Category ' + cat)];
    const chosen = namesList[Math.floor(Math.random() * namesList.length)];
    const name = `${chosen} - Category ${cat}`;
    const k = {
      id: 'kaiju-' + Math.floor(Math.random() * 1000000),
      name: name,
      category: cat,
      power: base.power || 0,
      maxHP: base.maxHP || base.hp || 100,
      hp: base.maxHP || base.hp || 100,
      armor: base.armor || 0,
      agility: base.agility || 0,
      moves: (base.moves && base.moves.slice()) || (KAIJU_MOVES.slice())
    };
    return k;
  }

  function startBattleFromSnapshot() {
    if(!state.snapshot) return;
    state.kaijuCategory = state.snapshot.kaijuCategory;
    state.battlefield = state.snapshot.battlefield;
    state.weather = state.snapshot.weather;
    state.timeOfDay = state.snapshot.timeOfDay;
    const pk = state.snapshot.jaegerKey;
    const tpl = JAEGERS[pk];
    state.jaeger = {
      key: pk, name: pk,
      power: tpl.power, agility: tpl.agility, armor: tpl.armor,
      maxHP: tpl.maxHP, hp: tpl.maxHP,
      moves: JSON.parse(JSON.stringify(tpl.moves))
    };
    state.distance = state.snapshot.startDistance;
    state.kaiju = createKaijuFromCategory(state.kaijuCategory);
	
	state.kaijuInitialCharge = true;
    state.kaijuPanic = false;
state.kaijuPanicSuppressed = false;
state.kaijuRushMode = false;
state.kaijuRushAttacksRemaining = 0;
state.kaijuPassiveApproach = false;

if (state.distance > 100) {
  state.kaijuInitialCharge = false;
  state.kaijuPassiveApproach = true;
  log(`${shortName(state.kaiju)} detected.`);
} else {
  state.kaijuInitialCharge = true;
  state.kaijuPassiveApproach = false;
  try {
    sfxAudio.pause();
    sfxAudio.currentTime = 0;
    sfxAudio.src = 'foghorn.mp3';
    sfxAudio.loop = false;
    sfxAudio.play().catch(()=>{});
  } catch(e){}
  log(`Foghorn sounded.`);
}
	
    state.totalDamageDealt = 0;
    state.battleStartTime = Date.now();
    setupBattleInit();
    renderJaegerCard();
    updateDisplays();
    state.mode = 'BATTLE';
    modeLabel.innerText = 'BATTLE';
    state.gameOver = false;
    clearKaijuLoop();
    state.kaijuIntervalId = setInterval(kaijuAI, 2000);
  }

  function restartBattleSame() {
    if(!state.snapshot) return;
    clearAllTimers();
    logEl.innerHTML = '';
    log(`Jaeger selected for deployment: ${state.snapshot.jaegerKey}`);
    transitionTo(()=> {
      startBattleFromSnapshot();
      hideResultOverlay();
    });
  }

  function redeployToSelection() {
    if(!state.snapshot) return;
    clearAllTimers();
    logEl.innerHTML = '';
    state.battlefield = state.snapshot.battlefield;
    state.weather = state.snapshot.weather;
    state.timeOfDay = state.snapshot.timeOfDay;
    state.kaijuCategory = state.snapshot.kaijuCategory;
    deployKaijuCat.innerText = 'Category ' + state.kaijuCategory;
    deployLocation.innerText = state.battlefield;
    deployWeather.innerText = state.weather;
    deployTimeOfDay.innerText = state.timeOfDay;
    transitionTo(()=> {
      battleScreen.classList.add('hidden');
      deployScreen.classList.remove('hidden');
      document.querySelectorAll('.jaeger-item').forEach(it => {
        it.classList.remove('selected');
        if(it.dataset.name === state.snapshot.jaegerKey) it.classList.add('selected');
      });
      const tpl = JAEGERS[state.snapshot.jaegerKey];
      state.jaeger = {
        key: state.snapshot.jaegerKey, name: state.snapshot.jaegerKey,
        power: tpl.power, agility: tpl.agility, armor: tpl.armor,
        maxHP: tpl.maxHP, hp: tpl.maxHP,
        moves: JSON.parse(JSON.stringify(tpl.moves))
      };
      deployBtn.disabled = false;
	  updateJaegerPreview(state.jaeger.name || state.snapshot.jaegerKey);
      log(`Jaeger selected for deployment: ${state.jaeger.name}`);
      hideResultOverlay();
    });
  }

  function endGame(reason, resultType='lose') {
    state.gameOver = true;
    state.mode = 'SETUP';
    modeLabel.innerText = 'RESULT';
    clearKaijuLoop();
    cancelKaijuPending('Battle ended: ' + reason);
    updateCooldownUI();
  }

  function clearKaijuLoop() {
    if(state.kaijuIntervalId) { clearInterval(state.kaijuIntervalId); state.kaijuIntervalId = null; }
  }
  function clearAllTimers() {
    clearKaijuLoop();
    if(state.kaijuPendingAttack && state.kaijuPendingAttack.timer) clearTimeout(state.kaijuPendingAttack.timer);
    if(state.qteTimeoutId) { clearTimeout(state.qteTimeoutId); state.qteTimeoutId = null; }
    if(state.globalDisableTimeoutId) { clearTimeout(state.globalDisableTimeoutId); state.globalDisableTimeoutId = null; }
    state.globalDisableExcept = null;
    state.globalDisableUntil = 0;
  }

  function setupBattleInit() {
    kaijuCategoryEl.innerText = 'Category ' + state.kaijuCategory;
    battlefieldEl.innerText = state.battlefield;
    weatherEl.innerText = state.weather;
    startDistanceEl.innerText = state.distance + ' m';
    distanceEl.innerText = Math.round(state.distance) + ' m';
    if(state.kaiju) {
      kNameEl.innerText = state.kaiju.name;
      kStatsEl.innerText = `Cat:${state.kaiju.category} Pwr:${state.kaiju.power || ''} Agi:${state.kaiju.agility || ''} Arm:${state.kaiju.armor || ''}`;
      kHPbar.style.width = (state.kaiju.hp / state.kaiju.maxHP * 100) + '%';
    }
  }

  function renderJaegerCard() {
    if(!state.jaeger) return;
    jNameEl.innerText = state.jaeger.name + (state.jaeger.mark ? ' ('+state.jaeger.mark+')' : '');
    jStatsEl.innerText = `Power:${state.jaeger.power} Agi:${state.jaeger.agility}% Armor:${state.jaeger.armor}%`;
    jHPbar.style.width = (state.jaeger.hp/state.jaeger.maxHP*100)+'%';
    moveBtnsDiv.innerHTML = '';
    state.jaeger.moves.forEach((m,idx) => {
      const btn = document.createElement('button');
      btn.className = 'small';
      btn.id = 'move_'+m.id;
      btn.innerHTML = `${m.name} <span style="font-size:11px;color:var(--muted)">(${m.type})</span>`;
      btn.onclick = () => playerAttack(m.id);
      moveBtnsDiv.appendChild(btn);
      const hint = document.createElement('span');
      hint.style.fontSize='11px'; hint.style.color='var(--muted)'; hint.style.marginLeft='8px';
      hint.textContent = ['Z','X','C','V'][idx] ? '('+['Z','X','C','V'][idx]+')' : '';
      btn.appendChild(hint);
    });
  }

  function updateDisplays() {
    if(state.jaeger) jHPbar.style.width = clamp(state.jaeger.hp/state.jaeger.maxHP*100,0,100)+'%';
    if(state.kaiju) kHPbar.style.width = clamp(state.kaiju.hp/state.kaiju.maxHP*100,0,100)+'%';
    distanceEl.innerText = Math.max(0,Math.round(state.distance)) + ' m';
  }

  moveFwdBtn.onclick = () => playerMove('forward');
  moveBackBtn.onclick = () => playerMove('back');

  function playerMove(dir) {
    if(state.mode !== 'BATTLE' && state.mode !== 'QTE') return;
    if(state.gameOver) return;
    const now = performance.now();
    if(now < (state.globalDisableUntil || 0) || (state.cooldowns['move'] && state.cooldowns['move'] > now)) { cooldownNote.innerText = 'Buttons are on cooldown... wait.'; return; }

    const loc = (state.battlefield || (state.snapshot && state.snapshot.battlefield) || 'Field');
    const MOVE_RANGES = {
      'Field':     { forward: [30,55], backward: [25,55] },
      'City':      { forward: [20,45], backward: [15,45] },
      'Sea':       { forward: [25,50], backward: [20,45] },
      'Underwater':{ forward: [20,40], backward: [15,40] }
    };
    const ranges = MOVE_RANGES[loc] || MOVE_RANGES['Field'];

    if(dir === 'forward') {
      const gain = randInt(ranges.forward[0], ranges.forward[1]);
      state.distance = clamp(state.distance - gain, 0, 1000);
      log(`${state.jaeger.name} moves forward ${gain} m → distance ${Math.round(state.distance)} m`);

      if(state.distance <= 5 && state.kaiju) {
        const baseCol = state.jaeger.power * 1.0;
        const colDmg = computeFinalDamage(baseCol, state.jaeger, state.kaiju, state.distance);
        if(colDmg > 0) {
          state.kaiju.hp = Math.max(0, state.kaiju.hp - colDmg);
          state.totalDamageDealt = (state.totalDamageDealt || 0) + colDmg;
          log(`${state.jaeger.name} charges into ${shortName(state.kaiju)} and deals ${colDmg} dmg.`);
          const recoil = Math.round(colDmg * 0.5);
          state.jaeger.hp = Math.max(0, state.jaeger.hp - recoil);
          log(`${state.jaeger.name} takes ${recoil} recoil damage from the impact.`);
        } else {
          log(`${state.jaeger.name} charged into ${shortName(state.kaiju)} but dealt no damage.`);
        }
      }

      setCooldown('move',700);
    } else {
      const gain = randInt(ranges.backward[0], ranges.backward[1]);
      state.distance = clamp(state.distance + gain, 0, 1000);
      log(`${state.jaeger.name} moves back ${gain} m → distance ${Math.round(state.distance)} m`);
      setCooldown('move',700);
      if(state.kaijuPendingAttack) {
        cancelKaijuPending(`${state.jaeger.name} moved away — ${state.kaiju.name}'s attack missed.`);
      }
      if(state.distance >= 1000) {
        log(`${state.jaeger.name} has fled and retreated — mission failed.`);
        showResultOverlay('retreat');
        endGame('retreat','lose');
        return;
      }
    }
    updateDisplays();
    updateCooldownUI();
  }
  
  function handleTaunt() {
  if (!state || state.gameOver) return;
  var now = performance.now();
  if (state.cooldowns && state.cooldowns['taunt'] && state.cooldowns['taunt'] > now) {
    if (typeof cooldownNote !== 'undefined') cooldownNote.innerText = 'Taunt on cooldown.';
    return;
  }
  try { if (sfxAudio) { sfxAudio.pause(); sfxAudio.currentTime = 0; sfxAudio.src = 'foghorn.mp3'; sfxAudio.loop = false; sfxAudio.play().catch(()=>{}); } } catch(e){}
  try { if (typeof setCooldown === 'function') setCooldown('taunt', 30000); } catch(e){}
  try { if (tauntBtn) { tauntBtn.disabled = true; setTimeout(function(){ tauntBtn.disabled = false; if (typeof updateCooldownUI === 'function') updateCooldownUI(); },30000); } } catch(e){}
  log(`${shortName(state.kaiju)} has detected your taunt!`);
  if (state.kaiju && state.kaijuPassiveApproach && state.distance > 100) {
    state.kaijuPassiveApproach = false;
    state.kaijuInitialCharge = true;
    try { log(`${shortName(state.kaiju)} is aggravated!`); } catch(e){}
    try { if (typeof kaijuAI === 'function') kaijuAI(); } catch(e){}
    return;
  }
  if (state.kaiju && state.kaijuPanic) {
    var cat = state.kaiju.category;
    if (!(cat === 'V' || cat === 'VI')) {
      state.kaijuPanic = false;
      state.kaijuPanicSuppressed = true;
      state.kaijuRushMode = true;
      state.kaijuRushAttacksRemaining = randInt(1,3);
      try { log(`${shortName(state.kaiju)} is aggravated!`); } catch(e){}
      try { if (typeof kaijuAI === 'function') kaijuAI(); } catch(e){}
    } else {
      try { log(`${shortName(state.kaiju)} is unfazed by your taunt.`); } catch(e){}
    }
  }
}
if (typeof tauntBtn !== 'undefined' && tauntBtn) tauntBtn.onclick = handleTaunt;

  function isAnyCooldownActive() {
    const now = performance.now();
    return Object.values(state.cooldowns).some(t=>t>now);
  }
  function setCooldown(id, ms) {
    state.cooldowns[id] = performance.now() + ms;
    updateCooldownUI();
    setTimeout(()=>{ delete state.cooldowns[id]; updateCooldownUI(); }, ms+20);
  }

  function updateCooldownUI() {
    const now = performance.now();
    const globalDisabled = now < (state.globalDisableUntil || 0);

    document.querySelectorAll('#moveBtns button').forEach(b => {
      const bid = b.id.replace('move_','');
      const onCd = state.cooldowns[bid] && state.cooldowns[bid] > now;
      const disabledByGlobal = globalDisabled && state.globalDisableExcept !== bid;
      b.disabled = disabledByGlobal || onCd;
    });

    const any = globalDisabled || Object.values(state.cooldowns).some(t => t > now);
    cooldownNote.innerText = any ? 'On cooldown...' : '';
  }

  window.addEventListener('keydown', (e) => {
    if(document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
    const key = e.key.toLowerCase();
    if(key === 'z' || key === 'Z') triggerAttackHotkey(0);
    if(key === 'x' || key === 'X') triggerAttackHotkey(1);
    if(key === 'c' || key === 'C') triggerAttackHotkey(2);
    if(key === 'v' || key === 'V') triggerAttackHotkey(3);
    if(key === 'a' || key === 'A') qteResolve('left');
    if(key === 'd' || key === 'D') qteResolve('right');
	if(key === 'w' || key === 'W') playerMove('forward');
    if(key === 's' || key === 'S') playerMove('backward');
	if(key === 'f' || key === 'F') handleTaunt();
    if(key === ' ') { e.preventDefault(); qteResolve('block'); }
  });

  function triggerAttackHotkey(idx) {
    if(!state.jaeger) return;
    const move = state.jaeger.moves[idx];
    if(move) playerAttack(move.id);
  }

  function playerAttack(moveId) {
    if((state.mode !== 'BATTLE' && state.mode !== 'QTE')) return;
    if(state.gameOver) return;

    const now = performance.now();
    if(now < (state.globalDisableUntil || 0)) {
      cooldownNote.innerText = 'Busy.';
      return;
    }

    const move = state.jaeger.moves.find(m => m.id === moveId);
    if(!move) return;

    if(state.cooldowns[move.id] && state.cooldowns[move.id] > now) {
      cooldownNote.innerText = 'Move on cooldown.';
      return;
    }
    if(move.unusableIn && move.unusableIn.includes(state.battlefield)) {
      log(`Move ${move.name} unusable in ${state.battlefield}.`);
      setCooldown(move.id, 600);
      return;
    }
    if(move.unusableInWeather && move.unusableInWeather.includes(state.weather)) {
      log(`${move.name} unusable in ${state.weather} weather.`);
      setCooldown(move.id, 600);
      return;
    }
    if(move.type === 'ranged' && state.distance >= 100) {
      log(`${move.name} out of range (out of range).`);
      setCooldown(move.id, 600);
      return;
    }
    if(move.type === 'melee' && state.distance > 40) {
      log(`Too far — ${move.name} can't reach.`);
      setCooldown(move.id, 600);
      return;
    }

    if(move.selfHPcostPct) {
      const cost = Math.ceil(state.jaeger.maxHP * (move.selfHPcostPct || 0));
      state.jaeger.hp = Math.max(0, state.jaeger.hp - cost);
      log(`${move.name} consumes ${cost} HP as cost.`);
    }

    const base = state.jaeger.power * (move.mult || 1);
    const dmg = computeFinalDamage(base, state.jaeger, state.kaiju, state.distance);
    if(dmg > 0) {
      state.kaiju.hp = Math.max(0, Math.round(state.kaiju.hp - dmg));
      if(state.kaiju && state.kaijuPanic && dmg > 0) {
        const cat = state.kaiju.category;
        if(!(cat === 'V' || cat === 'VI')) {
          state.kaijuPanic = false;
          state.kaijuPanicSuppressed = true;
          state.kaijuRushMode = true;
          state.kaijuRushAttacksRemaining = randInt(1,3);
          log(`${shortName(state.kaiju)}'s panic is broken by the assault and it rushes back!`);
        }
      }

      state.totalDamageDealt = (state.totalDamageDealt || 0) + dmg;
      log(`${state.jaeger.name} used ${move.name} and dealt ${Math.round(dmg)} dmg.`);
    } else {
      log(`${state.jaeger.name} used ${move.name}, but ${shortName(state.kaiju)} dodged!`);
    }

    setCooldown(move.id, move.cd || 1000);

    state.globalDisableUntil = now + 500;
    state.globalDisableExcept = move.id;
    if(state.globalDisableTimeoutId) { clearTimeout(state.globalDisableTimeoutId); state.globalDisableTimeoutId = null; }
    state.globalDisableTimeoutId = setTimeout(()=> {
      state.globalDisableExcept = null;
      state.globalDisableTimeoutId = null;
      updateCooldownUI();
    }, 500 + 30);

    updateDisplays();
    updateCooldownUI();
    checkEndConditions();
  }

  function computeFinalDamage(baseDamage, attacker, defender, distance) {
    let dodgeMul = 1;
    if(distance >= 31 && distance <= 40) dodgeMul = 4;
    else if(distance >= 26 && distance <= 30) dodgeMul = 3;
    else if(distance >= 21 && distance <= 25) dodgeMul = 2;
    else dodgeMul = 1;
    let dodgeChance = clamp(defender.agility/100 * dodgeMul, 0, 0.9);
    if(defender === state.kaiju && defender.hp < defender.maxHP*0.3) {
      dodgeChance *= 1.2; dodgeChance = Math.min(dodgeChance, 0.95);
    }
    if(Math.random() < dodgeChance) return 0;
    let closenessMul = 1;
    if(distance <= 10) {
      const extra = (10 - distance) * 0.1;
      closenessMul = 1 + extra;
      if(distance <= 1) closenessMul = 2;
      closenessMul = Math.min(closenessMul, 2);
    }
    const dmgAfterArmor = baseDamage * closenessMul * (1 - defender.armor/100);
    return Math.max(0, Math.round(dmgAfterArmor));
  }

  function kaijuAI() {
    if(state.gameOver || !state.kaiju) return;
    if(state.kaijuPendingAttack) return;
	
	if (state.kaijuPassiveApproach) {
  if (Math.random() < 0.5) {
    const gain = randInt(10, 30);
    state.distance = clamp(state.distance - gain, 0, 1000);
    log(`${shortName(state.kaiju)} prowls forward ${gain} m → distance ${Math.round(state.distance)} m`);
  } else {
    const gain = randInt(10, 30);
    state.distance = clamp(state.distance + gain, 0, 1000);
    log(`${shortName(state.kaiju)} shifts back ${gain} m → distance ${Math.round(state.distance)} m`);
  }
  if (typeof updateDisplays === 'function') updateDisplays();

  if (state.distance <= 100) {
    state.kaijuPassiveApproach = false;
    state.kaijuInitialCharge = true;
    log(`${shortName(state.kaiju)} has detected your position, aggravation detected, battle initiated.`);
    const gain = randInt(25,45);
    state.distance = clamp(state.distance - gain, 0, 1000);
    log(`${shortName(state.kaiju)} charges forward ${gain} m → distance ${Math.round(state.distance)} m`);
    if (typeof updateDisplays === 'function') updateDisplays();
    if (state.distance <= 60) {
      state.kaijuInitialCharge = false;
      log(`${shortName(state.kaiju)} slows to reconsider tactics.`);
    }
  }
  return;
}

    if(state.kaijuInitialCharge) {
      if(state.distance > 60) {
        const gain = randInt(25,45);
        state.distance = clamp(state.distance - gain, 0, 1000);
        log(`${shortName(state.kaiju)} charges forward ${gain} m → distance ${Math.round(state.distance)} m`);
        updateDisplays();

        if(state.distance <= 5 && state.jaeger) {
          const baseCol = (state.kaiju.power || 0) * 1.0;
          const colDmg = computeFinalDamage(baseCol, state.kaiju, state.jaeger, state.distance);
          if(colDmg > 0) {
            state.jaeger.hp = Math.max(0, state.jaeger.hp - colDmg);
            log(`${shortName(state.kaiju)} charges into ${state.jaeger.name} and deals ${colDmg} dmg.`);
            const recoil = Math.round(colDmg * 0.5);
            state.kaiju.hp = Math.max(0, state.kaiju.hp - recoil);
            state.totalDamageTaken = (state.totalDamageTaken || 0) + colDmg;
          } else {
            log(`${shortName(state.kaiju)} charged but dealt no damage.`);
          }
          updateDisplays();
          checkEndConditions();
          return;
        }

        if(state.distance <= 60) {
          state.kaijuInitialCharge = false;
          log(`${shortName(state.kaiju)} slows to reconsider tactics.`);
        }
        return;
      } else {
        state.kaijuInitialCharge = false;
      }
    }

    const cat = state.kaiju.category;
    const lowHP = state.kaiju.hp < state.kaiju.maxHP * 0.3;

    if(state.kaijuRushMode) {
      if(state.distance > 20) {
        const gain = randInt(25,45);
        state.distance = clamp(state.distance - gain, 0, 1000);
        log(`${shortName(state.kaiju)} rushes forward ${gain} m → distance ${Math.round(state.distance)} m`);
        updateDisplays();
        return;
      }
      if(state.kaijuRushAttacksRemaining && state.kaijuRushAttacksRemaining > 0) {
        state.kaijuRushAttacksRemaining--;
        queueKaijuAttack();
        if(state.kaijuRushAttacksRemaining <= 0) {
          state.kaijuRushMode = false;
          if(lowHP && !(cat === 'V' || cat === 'VI')) {
            state.kaijuPanic = true;
            state.kaijuPanicSuppressed = false;
          }
          log(`${shortName(state.kaiju)} finishes its counterattack and attempts to flee again.`);
        }
        return;
      } else {
        state.kaijuRushMode = false;
      }
    }

    if(!state.kaijuPanicSuppressed && lowHP && !(cat === 'V' || cat === 'VI')) {
      if(state.kaijuPanic || Math.random() < 0.7) {
        const baseMove = randInt(25,45);
        const gain = Math.round(baseMove * 1.2);
        state.distance = clamp(state.distance + gain, 0, 1000);
        state.kaijuPanic = true;
        log(`${shortName(state.kaiju)} panics and retreats ${gain} m → distance ${Math.round(state.distance)} m`);
        updateDisplays();
        return;
      }
    }

    if(state.kaijuPanic && lowHP && !(cat === 'V' || cat === 'VI')) {
      if(Math.random() < 0.5) {
        const gain = randInt(15,35);
        state.distance = clamp(state.distance + gain, 0, 1000);
        log(`${shortName(state.kaiju)} continues to panic and retreats ${gain} m → distance ${Math.round(state.distance)} m`);
        updateDisplays();
        return;
      } else {
        state.kaijuPanic = false;
      }
    }

    const choices = [];
    if(state.distance <= 60) choices.push('attack');
    choices.push('approach','retreat');
    const action = choices[randInt(0, choices.length-1)];

    if(action === 'attack') {
      queueKaijuAttack();
      return;
    } else if(action === 'approach') {
      const gain = randInt(25,45);
      state.distance = clamp(state.distance - gain, 0, 1000);
      log(`${shortName(state.kaiju)} charges forward ${gain} m → distance ${Math.round(state.distance)} m`);
      updateDisplays();

      if(state.distance <= 5 && state.jaeger) {
        const baseCol = (state.kaiju.power || 0) * 1.0;
        const colDmg = computeFinalDamage(baseCol, state.kaiju, state.jaeger, state.distance);
        if(colDmg > 0) {
          state.jaeger.hp = Math.max(0, state.jaeger.hp - colDmg);
          log(`${shortName(state.kaiju)} charges into ${state.jaeger.name} and deals ${colDmg} dmg.`);
          const recoil = Math.round(colDmg * 0.5);
          state.kaiju.hp = Math.max(0, state.kaiju.hp - recoil);
          state.totalDamageTaken = (state.totalDamageTaken || 0) + colDmg;
        } else {
          log(`${shortName(state.kaiju)} charged but dealt no damage.`);
        }
        updateDisplays();
        checkEndConditions();
        return;
      }

    } else {
      const gain = randInt(25,45);
      state.distance = clamp(state.distance + gain, 0, 1000);
      log(`${shortName(state.kaiju)} shifts back ${gain} m → distance ${Math.round(state.distance)} m`);
      updateDisplays();
    }
  }

  function queueKaijuAttack(move) {
	if (!move) {
      const moves = (state.kaiju && state.kaiju.moves && state.kaiju.moves.length)
        ? state.kaiju.moves
        : (typeof KAIJU_MOVES !== 'undefined' ? KAIJU_MOVES : []);
      if(moves.length === 0) return;
      move = moves[Math.floor(Math.random() * moves.length)];
    }
    if(move.type === 'ranged' && state.distance >= 100) {
      log(`${shortName(state.kaiju)} attempted ${move.name} but distance ${Math.round(state.distance)} m is too far — it moves closer instead.`);
      const g = randInt(20,45);
      state.distance = clamp(state.distance - g, 0, 1000);
      updateDisplays(); return;
    }
    state.kaijuPendingAttack = {
      move,
      side: ['left','right','middle'][randInt(0,2)],
      startAt: Date.now()
    };
    fovEl.classList.add('on');
    warnText.innerText = `Kaiju preparing ${move.name} — prepare to dodge!`;
    warnBox.classList.add('on');
    qteArea.style.display = 'block';
    state.mode = 'QTE'; modeLabel.innerText = 'QTE';
    let remain = 2.0;
    qteTimerEl.innerText = remain.toFixed(1);
    function tick() {
      remain -= 0.1;
      qteTimerEl.innerText = Math.max(0,remain).toFixed(1);
      if(remain <= 0) {
        resolveKaijuAttack(null);
      } else {
        state.qteTimeoutId = setTimeout(tick,100);
      }
    }
    state.qteTimeoutId = setTimeout(tick,100);
    state.kaijuPendingAttack.timer = setTimeout(()=> resolveKaijuAttack(null), 2000);
    log(`${shortName(state.kaiju)} is winding up ${move.name} — QTE (2.0s). Prepare to A/D or Space!`);
  }

  function cancelKaijuPending(reason) {
    if(!state.kaijuPendingAttack) return;
    const m = state.kaijuPendingAttack;
    if(m.timer) clearTimeout(m.timer);
    if(state.qteTimeoutId) clearTimeout(state.qteTimeoutId);
    state.kaijuPendingAttack = null;
    fovEl.classList.remove('on');
    warnBox.classList.remove('on');
    qteArea.style.display = 'none';
    state.mode = 'BATTLE'; modeLabel.innerText = 'BATTLE';
    log(reason || `{state.kaiju.name} stopped attacking.`);
  }

  function resolveKaijuAttack(playerChoice) {
    if(!state.kaijuPendingAttack) return;
    if(state.kaijuPendingAttack.timer) clearTimeout(state.kaijuPendingAttack.timer);
    if(state.qteTimeoutId) clearTimeout(state.qteTimeoutId);
    const attack = state.kaijuPendingAttack;
    state.kaijuPendingAttack = null;
    fovEl.classList.remove('on');
    warnBox.classList.remove('on');
    qteArea.style.display = 'none';
    state.mode = 'BATTLE'; modeLabel.innerText = 'BATTLE';
    const d = state.distance;
    if(attack.move.type === 'melee' && d > 40) {
      log(`${shortName(state.kaiju)} attempted ${attack.move.name} but target moved out of range (${d} m). Attack failed.`);
      updateDisplays(); return;
    }
    if(attack.move.type === 'ranged' && d >= 100) {
      log(`${shortName(state.kaiju)} attempted ${attack.move.name} moved out of range. Attack failed.`);
      updateDisplays(); return;
    }
    function passiveHitRoll() {
      let dodgeMul = 1;
      if(d >= 31 && d <= 40) dodgeMul = 4;
      else if(d >= 26 && d <= 30) dodgeMul = 3;
      else if(d >= 21 && d <= 25) dodgeMul = 2;
      else dodgeMul = 1;
      let dodgeChance = clamp(state.jaeger.agility/100 * dodgeMul, 0, 0.9);
      if(state.jaeger.hp < state.jaeger.maxHP*0.3) { dodgeChance *= 1.1; dodgeChance = Math.min(dodgeChance, 0.95); }
      return Math.random() < dodgeChance;
    }
    const move = attack.move;
    const attackSide = attack.side;
    if(playerChoice === null) {
      if(passiveHitRoll()) {
        log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} evaded the hit!`);
      } else {
        let dodgeMulDbg = 1;
      if(d >= 31 && d <= 40) dodgeMulDbg = 4;
      else if(d >= 26 && d <= 30) dodgeMulDbg = 3;
      else if(d >= 21 && d <= 25) dodgeMulDbg = 2;
      else dodgeMulDbg = 1;
      let dodgeChanceDbg = clamp(state.jaeger.agility/100 * dodgeMulDbg, 0, 0.9);
      if(state.jaeger.hp < state.jaeger.maxHP*0.3) { dodgeChanceDbg *= 1.1; dodgeChanceDbg = Math.min(dodgeChanceDbg, 0.95); }
      console.log('KAiju attack debug', {d, defenderAgility: state.jaeger.agility, defenderArmor: state.jaeger.armor, dodgeChanceDbg});
      const damage = computeFinalDamage(move.mult * state.kaiju.power, state.kaiju, state.jaeger, d);
        if(damage > 0) {
          state.jaeger.hp = Math.max(0, state.jaeger.hp - damage);
          log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} was hit for ${damage} dmg.`);
        } else {
          log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${shortName(state.kaiju)}'s attack did no damage.`);
        }
      }
    } else {
      if(attackSide === 'middle') {
        if(playerChoice === 'block') {
          if(passiveHitRoll()) {
            const damage = Math.round(computeFinalDamage(move.mult * state.kaiju.power, state.kaiju, state.jaeger, d) * 0.75);
            if(damage > 0) {
              state.jaeger.hp = Math.max(0, state.jaeger.hp - damage);
              log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). Block reduced damage — ${state.jaeger.name} took ${damage} dmg.`);
            } else {
              log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). Block held — ${shortName(state.kaiju)} missed!`);
            }
          } else {
            log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). Block held — ${shortName(state.kaiju)} missed!`);
          }
        } else {
          log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} didn't block — ${shortName(state.kaiju)} missed!`);
        }
      } else {
        const dirText = playerChoice === 'left' ? 'left' : (playerChoice === 'right' ? 'right' : playerChoice);

        if(playerChoice === 'block') {
          log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} blocked the attack!`);
        } else if(playerChoice !== attackSide) {
          log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} dodged ${dirText} — evaded the hit!`);
        } else {
          if(passiveHitRoll()) {
            log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} dodged ${dirText} — evaded the hit!`);
          } else {
            const damage = computeFinalDamage(move.mult * state.kaiju.power, state.kaiju, state.jaeger, d);
            if(damage > 0) {
              state.jaeger.hp = Math.max(0, state.jaeger.hp - damage);
              log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} dodged ${dirText} but were hit for ${damage} dmg.`);
            } else {
              log(`${shortName(state.kaiju)} used ${move.name} (${attackSide}). ${state.jaeger.name} dodged ${dirText} — evaded the hit!`);
            }
          }
        }
      }
    }
    updateDisplays();
    checkEndConditions();
  }

  function qteResolve(choice) {
    if(!state.kaijuPendingAttack) return;
    if(state.mode !== 'QTE') return;
    resolveKaijuAttack(choice);
  }
  dodgeLeftBtn.onclick = () => qteResolve('left');
  dodgeRightBtn.onclick = () => qteResolve('right');
  blockBtn.onclick = () => qteResolve('block');

  function checkEndConditions() {
    if(state.kaiju && state.kaiju.hp <= 0) {
      log(`${shortName(state.kaiju)} defeated! You win.`);
      showResultOverlay('win');
      endGame('victory','win');
      return;
    }
    if(state.jaeger && state.jaeger.hp <= 0) {
      showResultOverlay('lose');
      endGame('defeat','lose');
      return;
    }
  }

  function showResultOverlay(type) {
    resultOverlay.classList.remove('hidden');
    if(type === 'lose' || type === 'retreat') resultMain.textContent = 'Mission Status: Failure';
    else resultMain.textContent = 'Mission Status: Successful';

    const totalDamage = state.totalDamageDealt || 0;
    const now = Date.now();
    const durationMs = state.battleStartTime ? Math.max(0, now - state.battleStartTime) : 0;
    const hh = String(Math.floor(durationMs/3600000)).padStart(2,'0');
    const mm = String(Math.floor((durationMs%3600000)/60000)).padStart(2,'0');
    const ss = String(Math.floor((durationMs%60000)/1000)).padStart(2,'0');
    const durationStr = `${hh}:${mm}:${ss}`;

    let statHtml = `<div class="result-line">Total Damage Dealt: <strong style="color:var(--accent)">${totalDamage}</strong></div>`;
    statHtml += `<div class="result-line">Battle Duration: <strong style="color:var(--accent)">${durationStr}</strong></div>`;

    if(type === 'retreat') {
      const jaegerPct = state.jaeger ? ((state.jaeger.hp/state.jaeger.maxHP)*100).toFixed(2) : '0.00';
      const kaijuPct = state.kaiju ? ((state.kaiju.hp/state.kaiju.maxHP)*100).toFixed(2) : '0.00';
      statHtml += `<div class="result-line">Jaeger HP Remaining: <strong style="color:var(--accent)">${jaegerPct}%</strong></div>`;
      statHtml += `<div class="result-line">Kaiju HP Remaining: <strong style="color:var(--accent)">${kaijuPct}%</strong></div>`;
      statHtml += `<div class="result-line" style="color:var(--muted)">Pilot retreated — mission counted as failure.</div>`;
    } else if(type === 'lose') {
      const percent = state.kaiju ? ((state.kaiju.hp/state.kaiju.maxHP)*100).toFixed(02) : '0.00';
      statHtml += `<div class="result-line">Kaiju HP Remaining: <strong style="color:var(--accent)">${percent}%</strong></div>`;
    } else {
      const percent = state.jaeger ? ((state.jaeger.hp/state.jaeger.maxHP)*100).toFixed(02) : '0.00';
      statHtml += `<div class="result-line">Jaeger HP Remaining: <strong style="color:var(--accent)">${percent}%</strong></div>`;
    }

    resultStats.innerHTML = statHtml;

    retryBtn.onclick = () => {
      transitionTo(()=> {
        restartBattleSame();
      });
    };
    redeployBtn.onclick = () => {
      transitionTo(()=> {
        redeployToSelection();
      });
    };
    mainMenuBtn.onclick = () => {
      transitionTo(()=> { location.reload(); });
    };
  }
  function hideResultOverlay() { resultOverlay.classList.add('hidden'); }

  populateInstructions();
  window.addEventListener('beforeunload', ()=> { clearAllTimers(); });
  
function shortName(entityOrName) {
  const name = typeof entityOrName === 'string' ? entityOrName : (entityOrName && entityOrName.name) || '';
  return name.split(' - ')[0];
}
</script>

<script>
(function(){
  const seq = [
    {text: "Initiating Systems", dots:true, duration:4000},
    {text: "Systems Initiated", dots:false, duration:2000},
    {text: "Calibrating", dots:true, duration:4000},
    {text: "Systems Calibrated", dots:false, duration:2000},
    {text: "Welcome, Ranger", dots:false, duration:0}
  ];
  const initScreen = document.getElementById('initScreen');
  const title = document.getElementById('initTitle');
  const status = document.getElementById('initStatus');
  const clickHint = document.getElementById('initClickHint');

  const DOTS = ['.', '..', '...'];
  let dotsTid = null;
  function startDotsLoop(targetEl, interval=450) {
    if(!targetEl) return null;
    let idx = 0;
    targetEl.textContent = DOTS[idx];
    return setInterval(()=> { idx = (idx+1) % DOTS.length; targetEl.textContent = DOTS[idx]; }, interval);
  }
  function stopDotsLoop(tid) { if(tid) clearInterval(tid); if(status) status.textContent=''; }

  function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

  async function runSequence(){
    for (let step of seq){
      title.textContent = step.text;
      if(step.dots) {
        if(dotsTid) { stopDotsLoop(dotsTid); dotsTid = null; }
        dotsTid = startDotsLoop(status, 450);
        await sleep(step.duration);
        stopDotsLoop(dotsTid);
        dotsTid = null;
      } else {
        status.textContent = '';
        if(step.duration > 0) await sleep(step.duration);
      }
    }
    clickHint.style.display = 'block';
    initScreen.setAttribute('aria-hidden','false');
  }

  const audioA = document.getElementById('bgAudioA');
  const audioB = document.getElementById('bgAudioB');
  let cur = null;
  let fadeInterval = null;
  function setAudioVisible(el, v){ try{ el.style.display = v ? '' : 'none'; }catch(e){} }
  function crossfadeTo(src, duration=1500){
    const incoming = (cur === 'A' || cur === null) ? audioB : audioA;
    const outgoing = (incoming === audioA) ? audioB : audioA;
    try {
      incoming.src = src;
      incoming.loop = true;
      incoming.volume = 0;
      incoming.play().catch(()=>{});
      setAudioVisible(incoming, true);
    } catch(e){}
    const steps = 30;
    const stepTime = Math.max(10, Math.floor(duration/steps));
    let step = 0;
    if (fadeInterval) clearInterval(fadeInterval);
    fadeInterval = setInterval(()=>{
      step++;
      const t = step / steps;
      incoming.volume = Math.min(1, t);
      if (outgoing) outgoing.volume = Math.max(0, 1 - t);
      if (step >= steps){
        clearInterval(fadeInterval);
        fadeInterval = null;
        if (outgoing && !outgoing.paused){
          try { outgoing.pause(); } catch(e){}
        }
        incoming.volume = 1;
        cur = (incoming === audioA) ? 'A' : 'B';
      }
    }, stepTime);
  }
  function playImmediate(src){
    try{
      audioB.pause(); audioB.currentTime = 0;
      audioA.src = src; audioA.loop = true; audioA.volume = 1;
      audioA.play().catch(()=>{});
      setAudioVisible(audioA, true); setAudioVisible(audioB, false);
      cur = 'A';
    }catch(e){}
  }

  runSequence();

  initScreen.addEventListener('click', function handler(e){
    if (clickHint.style.display === 'block'){
      playImmediate('pacific.mp3');
      initScreen.classList.add('hidden');
      setTimeout(()=>{ initScreen.style.display = 'none'; }, 1000);
      initScreen.removeEventListener('click', handler);
    }
  });

  const playBtn = document.getElementById('playBtn');
  const deployBtn = document.getElementById('deployBtn');
  if (playBtn){
    playBtn.addEventListener('click', ()=>{ crossfadeTo('shatterdome.mp3', 1500); });
  }
  if (deployBtn){
    deployBtn.addEventListener('click', ()=>{ crossfadeTo('family.mp3', 1500); });
  }

})();
</script>
</body>
</html>
